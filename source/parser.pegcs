{
  require 'coffee-script'
  @_ = require './utilities'
  assert = require 'assert'

  @Scope = require('./scopes/Scope')
  @ScopeType = require('./scopes/ScopeType')

  @ColorValue = require('./values/ColorValue')
  @AttributeReferenceValue = require('./values/AttributeReferenceValue')
  @FunctionValue = require("./values/FunctionValue")

  @ValuesDefinition = require("./ValuesDefinition")

  @LiteralExpression = require('./expressions/LiteralExpression')
  @StringExpression = require("./expressions/StringExpression")
  @ValueMacroReferenceExpression = require('./expressions/ValueMacroReferenceExpression')
  @ComparisonOperatorExpression = require('./expressions/ComparisonOperatorExpression')
  @TypeCheckOperatorExpression = require('./expressions/TypeCheckOperatorExpression')
  @BooleanLogicExpression = require('./expressions/BooleanLogicExpression')
  @SetOperatorExpression = require('./expressions/SetOperatorExpression')
  @NotOperatorExpression = require('./expressions/NotOperatorExpression')
  @ArrayExpression = require('./expressions/ArrayExpression')
  @MapExpression = require('./expressions/MapExpression')
  @DotExpression = require('./expressions/DotExpression')
  @SubscriptExpression = require('./expressions/SubscriptExpression')
  @ArithmeticOperatorExpression = require('./expressions/ArithmeticOperatorExpression')

  @globalScope = @scope = new @Scope(null)
  @pushScope = (scope) =>
    assert(scope instanceof @Scope, "Malformed arguments to pushScope")
    assert(scope.parent == @scope, "Child scope must be parent of current scope")
    @scope = scope
  @popScope = =>
    @scope = @scope.parent
}

global = statements { @globalScope.evaluateGlobalScope() }

identifier = a:[A-Za-z$]b:[a-zA-Z0-9-_]* { a + b.join("") }

comment = "//" [^\n\r]* { null }

whitespaceWeak = " " / "\t" { null }
whitespaceStrong = comment? "\n" / "\r" { null }
whitespace = whitespaceStrong / whitespaceWeak { null }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                Expressions                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

expressionsSeperatorWeak = ((whitespaceWeak* "," whitespaceWeak*) / (whitespaceWeak)+) { null }
expressionsSeperatorStrong = ((whitespace* "," whitespace*) / whitespace+) { null }

// TODO these should return a Values object
expressionsUnnamedWeak =
  head:expression tail:(expressionsSeperatorWeak expression)* { [head].concat(tail.map (e) -> e[1]) } /
  "(" whitespace* expressions:expressionsUnnamedStrong whitespace* ")" { expressions }

expressionsUnnamedStrong =
  head:expression tail:(expressionsSeperatorStrong expression)* { [head].concat(tail.map (e) -> e[1]) }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Statements                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

statementSeperator = whitespaceWeak* (";" / whitespaceStrong) whitespace* { null }

statements = whitespace* (statement (statementSeperator statement)* statementSeperator? whitespace*)? comment? whitespace*

statement =
  comment /
  valueMacroDefinition /
  layer /
  class /
  propertyMacroDefinition /
  loop /
  property

property =
  name:identifier ":" whitespace* expressions:expressionsUnnamedWeak { @scope.addProperty(name, expressions) } /
  name:identifier { @scope.addProperty(name, []) }

valueMacroDefinition =
  name:identifier args:valueMacroDefinitionArguments whitespace* "=" whitespace* expressions:expressionsUnnamedWeak { @scope.addValueMacro(name, args, expressions) }

valueMacroDefinitionArguments =
  "(" whitespace* head:valueMacroDefinitionArgument tail:(expressionsSeperatorStrong valueMacroDefinitionArgument)* whitespace* ")" { new @ValuesDefinition([head].concat(@_.pluck(tail, 1)), @scope) } /
  "" { @ValuesDefinition.ZERO }

valueMacroDefinitionArgument =
  name:identifier whitespace* "=" whitespace* expression:expression { name: name, expression: expression } /
  name:identifier { name: name }

loop =
  ("for" whitespace+ keyIdentifier:identifier expressionsSeperatorStrong valueIdentifier:identifier whitespace+ "in" whitespace+ collection:valueExpression whitespace* { @pushScope(@scope.addLoop(valueIdentifier, keyIdentifier, collection)) }) scope /
  ("for" whitespace+ valueIdentifier:identifier whitespace+ "in" whitespace+ collection:expression whitespace* { @pushScope(@scope.addLoop(valueIdentifier, null, collection)) }) scope

layer =
  ("#" name:identifier? { @pushScope(@scope.addLayerScope(name)) }) scope

class =
  ("." name:identifier { @pushScope(@scope.addClassScope(name)) }) scope

propertyMacroDefinition =
  (name:identifier args:propertyMacroDefinitionArguments whitespace* "=" whitespace* { @pushScope(@scope.addPropertyMacro(name, args)) }) scope

propertyMacroDefinitionArguments =
  "(" whitespace* head:propertyMacroDefinitionArgument tail:(expressionsSeperatorWeak propertyMacroDefinitionArgument)* whitespace* ")" { new @ValuesDefinition([head].concat(tail.map (e) -> e[1]), @scope) } /
  "" { @ValuesDefinition.ZERO }

propertyMacroDefinitionArgument =
  name:identifier whitespace* "=" whitespace* expression:expression { name: name, expression:expression } /
  name:identifier { name: name }

scope =
  (whitespace* "{" body:statements "}" { @popScope() })

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Expression                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

expression =
  filterExpression /
  arithmeticOperatorExpression

/////////////////////////////////////////////
//           Filter Expression             //
/////////////////////////////////////////////

filterExpression =
  notOperatorExpression /
  booleanLogicExpression /
  filterWeakExpression

booleanLogicExpression =
  left:filterWeakExpression whitespace* operator:("||" / "&&") whitespace* right:expression { new @BooleanLogicExpression(operator, [left, right]) }

notOperatorExpression =
  "!" whitespace* expression:expression { new @NotOperatorExpression(expression) }

/////////////////////////////////////////////
//       Logic Operator Expression         //
/////////////////////////////////////////////

filterWeakExpression =
  groupExpression /
  filterWeakInfixOperatorExpression /
  typeCheckOperatorExpression

groupExpression =
  "(" expression:expression ")"
  { expression }

typeCheckOperatorExpression =
  "is" whitespace* type:expression
  { new @TypeCheckOperatorExpression(type) }

filterWeakInfixOperatorExpression =
  left:valueExpression whitespace*
  operator:("==" / ">=" / "<=" / "<" / ">" / "!=" / "in" / "!in") whitespace*
  right:arithmeticOperatorExpression
  {
    if operator in ["in", "!in"] then new @SetOperatorExpression(left, operator, right)
    else new @ComparisonOperatorExpression(left, operator, right)
  }

/////////////////////////////////////////////
//     Arithmetic Operator Expression      //
/////////////////////////////////////////////

arithmeticOperatorExpression =
  "(" whitespace* expression:arithmeticOperatorExpression whitespace* ")" { expression } /
  left:valueExpression rest:(whitespace* operator:("+" / "-" / "/" / "*") whitespace* right:arithmeticOperatorExpression)?
  {
    if rest then new @ArithmeticOperatorExpression(left, rest[1], rest[3])
    else left
  }

/////////////////////////////////////////////
//         Weak Value Expression           //
/////////////////////////////////////////////

valueExpression =
  dotExpression /
  subscriptExpression /
  literalExpression /
  valueMacroReferenceExpression /
  stringExpression /
  mapExpression /
  arrayExpression

dotExpression =
  base:(arrayExpression / mapExpression / valueMacroReferenceExpression) "." property:(integer / identifier) { new @DotExpression(base, property) }

subscriptExpression =
  base:(arrayExpression / mapExpression / valueMacroReferenceExpression) "[" property:valueExpression "]" { new @SubscriptExpression(base, property) }

literalExpression =
  value:value { new @LiteralExpression(value) }

valueMacroReferenceExpression =
  name:identifier expressions:valueMacroReferenceExpressionArguments { new @ValueMacroReferenceExpression(name, expressions) }

valueMacroReferenceExpressionArguments =
  "(" whitespace* head:valueMacroReferenceExpressionArgument tail:(expressionsSeperatorStrong valueMacroReferenceExpressionArgument)* whitespace* ")" { [head].concat(@_.pluck(tail, 1) ) } /
  "" { [] }

valueMacroReferenceExpressionArgument =
  name:(identifier / integer) whitespace* ":" whitespace* expression:valueExpression { name: name, expression: expression } /
  expression:valueExpression { { expression: expression } }

stringExpression =
  "\"" body:[^\"]* "\"" { new @StringExpression(body.join("")) }

arrayExpression =
  "[" whitespace* expressions:expressionsUnnamedStrong whitespace* "]" { new @ArrayExpression(expressions) }

mapExpression =
  "[" whitespace* expressions:mapExpressionItems whitespace* "]" { new @MapExpression(expressions) }

mapExpressionItems =
  head:mapExpressionItem tail:(expressionsSeperatorStrong mapExpressionItem)* { [head].concat(tail.map (e) -> e[1]) }

mapExpressionItem =
  name:(identifier / integer) whitespace* ":" whitespace* expression:expression { name: name, expression: expression; name: name, expression: expression }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                  Value                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

value =
  null /
  boolean /
  number /
  attributeReferenceValue /
  colorValue

boolean =
  "true" { true } /
  "false" { false }

null =
  "null" { null }

number =
  before:integer? "." after:([0-9]+) { (before + parseFloat("." + after.join(""))) } /
  number:integer { number }

integer =
  head:[1-9-] tail:[0-9]* { parseInt(head + tail.join("")) } /
  "0" { 0 }

attributeReferenceValue =
  "@" name:identifier { new @AttributeReferenceValue(name) }

colorValue =
  "#" color:[0-9a-f]+ { @ColorValue.hex(color.join("")) }

