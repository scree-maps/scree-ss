{
  require 'coffee-script'
  @_ = require './utilities'
  assert = require 'assert'

  @_.extend(@, require("./index"))

  @pushScope = (scope = new @Scope(@scope)) =>
    assert(scope instanceof @Scope, "Malformed arguments to pushScope")
    assert(scope.parent == @scope, "Next scope must be child of current scope")
    @scope = scope

  @popScope = (statements) =>
    scopeOld = @scope
    scopeNew = @scope.parent
    @scope = scopeNew
    return scopeOld

  @rehead = (head, body) => [head].concat(@_.pluck(body, 1))
}

identifier = a:[A-Za-z]b:[a-zA-Z0-9-_]* { a + b.join("") }

comment = "//" [^\n\r]* { null }

whitespaceWeak = " " / "\t" { null }
whitespaceStrong = comment? "\n" / "\r" { null }
whitespace = whitespaceStrong / whitespaceWeak { null }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                  Scope                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

global = ({ @globalScope = @scope = @Scope.createGlobal() }) statements:statementSet { @globalScope.addStatements(statements); @globalScope }

scope = ({ @pushScope() }) whitespace* "{" body:statementSet "}" { @scope.addStatements(body); @popScope(body) }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                               StatementSet                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

statementSetSeperator = whitespaceWeak* (";" / whitespaceStrong) whitespace* { null }

statementSet = whitespace* statements:(head:statement tail:(statementSetSeperator statement)* statementSetSeperator? whitespace* { @rehead(head, tail) })? comment? whitespace* { @_.compact(statements) || [] }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Statement                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

statement =
  comment /
  valueMacroDefinitionStatement /
  layerStatement /
  classStatement /
  propertyMacroDefinitionStatement /
  loopStatement /
  conditionalStatement /
  propertyMacroStatement /
  propertyStatement

propertyMacroStatement =
  name:identifier whitespace* "(" whitespace* expressions:expressionSetMixedStrong whitespace* ")" { new @PropertyMacroStatement(name, expressions) } /
  name:identifier whitespace* "(" whitespace* ")" { new @PropertyMacroStatement(name, @ExpressionSet.ZERO) }

propertyStatement =
  name:identifier whitespace* ":" whitespace* expressions:expressionSetUnnamedWeak { new @PropertyStatement(name, expressions) }

valueMacroDefinitionStatement =
  name:identifier whitespace* args:expressionSetDefinition whitespace* "=" whitespace* body:expression { new @ValueMacroDefinitionStatement(name, args, body) }

loopStatement =
  "for" whitespace+ keyIdentifier:identifier expressionSetSeperatorStrong valueIdentifier:identifier whitespace+ "in" whitespace+ collection:expression whitespace* scope:scope
    { new @LoopStatement(scope, valueIdentifier, keyIdentifier, collection) } /
  "for" whitespace+ valueIdentifier:identifier whitespace+ "in" whitespace+ collection:expression whitespace* scope:scope
    { new @LoopStatement(scope, valueIdentifier, null, collection) }

conditionalStatement =
  ifItem:conditionalStatementIf elseIfItems:( whitespace* conditionalStatementElseIf  )* whitespace* elseItem:conditionalStatementElse? { new @ConditionalStatement(@_.compact(@rehead(ifItem, elseIfItems).concat([elseItem]))) }

conditionalStatementIf =
  "if" whitespace+ condition:expression whitespace* scope:scope { {condition: condition, scope: scope} }

conditionalStatementElseIf =
  "else if" whitespace+ condition:expression whitespace* scope:scope { {condition: condition, scope: scope} }

conditionalStatementElse =
  "else" whitespace* scope:scope { {condition: new @LiteralExpression(true), scope: scope} }

layerStatement =
  "#" name:identifier? body:scope { new @LayerStatement(name, body) }

classStatement =
  "." name:identifier body:scope { new @ClassStatement(name, body) }

propertyMacroDefinitionStatement =
  name:identifier args:expressionSetDefinition whitespace* "=" whitespace* body:scope { new @PropertyMacroDefinitionStatement(name, args, body) }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                              Expression Sets                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

expressionSetSeperatorWeak = ((whitespaceWeak* "," whitespaceWeak*) / (whitespaceWeak)+) { null }
expressionSetSeperatorStrong = ((whitespace* "," whitespace*) / whitespace+) { null }

expressionSetUnnamedWeak =
  head:expression tail:(expressionSetSeperatorWeak expression)* { new @ExpressionSet(@_.map(@rehead(head, tail), (expression) => {expression: expression} ) ) } /
  "(" whitespace* expressions:expressionSetUnnamedStrong whitespace* ")" { expressions }

expressionSetUnnamedStrong =
  head:expression tail:(expressionSetSeperatorStrong expression)* { new @ExpressionSet(@_.map(@rehead(head, tail), (expression) => {expression: expression} ) )  }

expressionSetNamedStrong =
  head:expressionSetNamedStrongItem tail:(expressionSetSeperatorStrong expressionSetNamedStrongItem)* { new @ExpressionSet(@rehead(head, tail)) }

expressionSetNamedStrongItem =
  name:(identifier / integer) whitespace* ":" whitespace* expression:expression { name: name, expression: expression; name: name, expression: expression }

expressionSetMixedStrong =
  head:expressionSetMixedStrongItem tail:(expressionSetSeperatorStrong expressionSetMixedStrongItem)* { new @ExpressionSet(@rehead(head, tail) ) }

expressionSetMixedStrongItem =
  name:(identifier / integer) whitespace* ":" whitespace* expression:expression { name: name, expression: expression } /
  expression:expression { { expression: expression } }


expressionSetDefinition =
  "(" whitespace* "*" whitespace* ")" { @ValueSetDefinition.WILDCARD } /
  "(" whitespace* head:expressionSetDefinitionItem tail:(expressionSetSeperatorStrong expressionSetDefinitionItem)* whitespace* ")" { new @ValueSetDefinition(@rehead(head, tail), @scope) } /
  "" { @ValueSetDefinition.ZERO }

expressionSetDefinitionItem =
  name:identifier whitespace* "=" whitespace* expression:expression { name: name, expression: expression } /
  name:identifier { name: name }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Expression                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

expression =
  filterExpression /
  arithmeticExpression

/////////////////////////////////////////////
//           Filter Expression             //
/////////////////////////////////////////////

filterExpression =
  notOperatorExpression /
  booleanLogicExpression /
  filterStrongExpression

booleanLogicExpression =
  left:filterStrongExpression whitespace* operator:("||" / "&&") whitespace* right:expression { new @BooleanLogicExpression(operator, [left, right]) }

notOperatorExpression =
  "!" whitespace* expression:expression { new @NotOperatorExpression(expression) }

/////////////////////////////////////////////
//         Filter Weak Expression          //
/////////////////////////////////////////////

filterStrongExpression =
  groupExpression /
  setOperatorExpression /
  comparisonOperatorExpression /
  typeCheckOperatorExpression

groupExpression =
  whitespace* "(" expression:expression ")" { expression }

typeCheckOperatorExpression =
  whitespace* "is" whitespace* type:arithmeticExpression { new @TypeCheckOperatorExpression(type) }

comparisonOperatorExpression =
  whitespace* left:arithmeticExpression whitespace* operator:("==" / ">=" / "<=" / "<" / ">" / "!=") whitespace* right:arithmeticExpression { new @ComparisonOperatorExpression(left, operator, right) }

setOperatorExpression =
  whitespace* left:arithmeticExpression whitespace+ operator:("in" / "!in") whitespace+ right:arithmeticExpression { new @SetOperatorExpression(left, operator, right) }

/////////////////////////////////////////////
//     Arithmetic Operator Expression      //
/////////////////////////////////////////////

arithmeticExpression =
  left:arithmeticStrongExpression whitespaceWeak* operator:("+" / "-") whitespaceWeak* right:arithmeticExpression { new @ArithmeticOperatorExpression(left, operator, right) } /
  arithmeticStrongExpression

arithmeticStrongExpression =
  left:propertyAccessExpression whitespaceWeak* operator:("/" / "*") whitespaceWeak* right:arithmeticStrongExpression { new @ArithmeticOperatorExpression(left, operator, right) } /
  "(" whitespace* expression:arithmeticExpression whitespace* ")" { expression } /
  conditionalExpression

/////////////////////////////////////////////
//            Conditional Expression       //
/////////////////////////////////////////////

conditionalExpression =
  head:propertyAccessExpression whitespaceWeak* '??' whitespaceWeak* tail:conditionalExpression { new @NullCoalescingExpression(head, tail) } /
  condition:propertyAccessExpression whitespaceWeak* '?' whitespaceWeak* trueExpression:conditionalExpression whitespaceWeak* ':' whitespaceWeak* falseExpression:conditionalExpression { new @TernaryExpression(condition, trueExpression, falseExpression) } /
  propertyAccessExpression

/////////////////////////////////////////////
//            Value Expression             //
/////////////////////////////////////////////

propertyAccessExpression =
  head:atomicExpression accesses:(
    "." (integer / identifier) /
    "[" expression "]"
  )* {
    output = head

    for access in accesses
      if access[0] == "."
        output = new @PropertyAccessExpression(output, new @LiteralExpression(access[1]))
      else if access[0] == "["
        output = new @PropertyAccessExpression(output, access[1])

    return output
  }

/////////////////////////////////////////////
//           Weak Value Expression         //
/////////////////////////////////////////////

atomicExpression =
  javaScriptExpression /
  literalExpression /
  valueMacroReferenceExpression /
  stringExpression /
  mapExpression /
  arrayExpression

literalExpression =
  value:value { new @LiteralExpression(value) }

valueMacroReferenceExpression =
  name:identifier whitespace* "(" whitespace* expressions:expressionSetMixedStrong whitespace* ")" { new @ValueMacroReferenceExpression(name, expressions) } /
  name:identifier (whitespace* "(" whitespace* ")")? { new @ValueMacroReferenceExpression(name, @ExpressionSet.ZERO) }

stringExpression =
  "\"" body:[^\"]* "\"" { new @StringExpression(body.join("")) } /
  "'" body:[^\']* "'" { new @StringExpression(body.join("")) }

arrayExpression =
  "[" whitespace* expressions:expressionSetUnnamedStrong whitespace* "]" { new @ArrayExpression(expressions) }

mapExpression =
  "[" whitespace* expressions:expressionSetNamedStrong whitespace* "]" { new @MapExpression(expressions) }

javaScriptExpression =
  "`" body:[^\`]* "`" { new @JavaScriptExpression(body.join("")) }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                  Value                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

value =
  null /
  boolean /
  number /
  attributeReferenceValue /
  colorValue

boolean =
  "true" { true } /
  "false" { false }

null =
  "null" { null }

number =
  before:integer? "." after:([0-9]+) { (before + parseFloat("." + after.join(""))) } /
  number:integer { number }

integer =
  head:[1-9-] tail:[0-9]* { parseInt(head + tail.join("")) } /
  "0" { 0 }

attributeReferenceValue =
  "@" name:identifier { new @AttributeReferenceValue(name) }

colorValue =
  "#" color:[0-9a-fA-F]+ { @ColorValue.hex(color.join("")) }
