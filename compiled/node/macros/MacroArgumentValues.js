// Generated by CoffeeScript 1.8.0
(function() {
  var MacroArgumentValues, assert, _;

  _ = require('../utilities');

  assert = require('assert');

  module.exports = MacroArgumentValues = (function() {
    MacroArgumentValues.createFromExpressions = function(args, scope, options) {
      var arg, argValues, namedArgs, positionalArgs, _i, _len;
      positionalArgs = [];
      namedArgs = {};
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        argValues = arg.expression.toValues(scope, options);
        if (arg.name) {
          assert(argValues.length === 1);
          namedArgs[arg.name] = argValues[0];
        } else {
          positionalArgs = positionalArgs.concat(argValues);
        }
      }
      return new MacroArgumentValues(positionalArgs, namedArgs);
    };

    function MacroArgumentValues(positionalArgs, namedArgs) {
      this.positionalArgs = positionalArgs;
      this.namedArgs = namedArgs;
      this.length = this.positionalArgs.length + _.values(this.namedArgs).length;
    }

    MacroArgumentValues.prototype.matches = function(argDefinition) {
      var definition, indicies, name, positionalIndex, value, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (!argDefinition) {
        return true;
      }
      indicies = _.times(argDefinition.length, function() {
        return false;
      });
      _ref = this.namedArgs;
      for (name in _ref) {
        value = _ref[name];
        if (!argDefinition.namedArgs[name]) {
          return false;
        }
        indicies[argDefinition.namedArgs[name].index] = true;
      }
      positionalIndex = -1;
      _ref1 = this.positionalArgs;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        value = _ref1[_i];
        while (indicies[++positionalIndex] && positionalIndex < argDefinition.definitions.length) {
          null;
        }
        if (positionalIndex >= argDefinition.definitions.length) {
          return false;
        }
        indicies[positionalIndex] = true;
      }
      _ref2 = argDefinition.definitions;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        definition = _ref2[_j];
        if (definition.expression) {
          indicies[definition.index] = true;
        }
      }
      return _.all(indicies);
    };

    MacroArgumentValues.prototype.toArguments = function(argDefinition, options) {
      var args, definition, name, positionalIndex, value, _i, _len, _ref, _ref1;
      assert(this.matches(argDefinition));
      if (!argDefinition) {
        return _.extend(_.objectMap(this.positionalArgs, function(index, values) {
          return [index, values];
        }), this.namedArgs);
      } else {
        args = {};
        _ref = this.namedArgs;
        for (name in _ref) {
          value = _ref[name];
          args[name] = value;
        }
        positionalIndex = 0;
        _ref1 = argDefinition.definitions;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          definition = _ref1[_i];
          if (!args[definition.name]) {
            if (positionalIndex < this.positionalArgs.length) {
              args[definition.name] = this.positionalArgs[positionalIndex++];
            } else {
              if (!argDefinition.scope) {
                debugger;
              }
              args[definition.name] = definition.expression.toValue(argDefinition.scope, options);
            }
          }
        }
        return args;
      }
    };

    return MacroArgumentValues;

  })();

}).call(this);
