{
  require 'coffee-script'
  @_ = require './utilities'

  @GlobalScope = require('./scopes/GlobalScope')

  @ColorValue = require('./values/ColorValue')
  @AttributeReferenceValue = require('./values/AttributeReferenceValue')
  @LiteralValue = require("./values/LiteralValue")
  @ArrayValue = require("./values/ArrayValue")
  @FunctionValue = require("./values/FunctionValue")

  @LiteralExpression = require('./expressions/LiteralExpression')
  @StringExpression = require("./expressions/StringExpression")
  @ValueMacroReferenceExpression = require('./expressions/ValueMacroReferenceExpression')
  @ComparisonOperatorExpression = require('./expressions/ComparisonOperatorExpression')
  @TypeCheckOperatorExpression = require('./expressions/TypeCheckOperatorExpression')
  @BooleanLogicExpression = require('./expressions/BooleanLogicExpression')
  @SetOperatorExpression = require('./expressions/SetOperatorExpression')
  @NotOperatorExpression = require('./expressions/NotOperatorExpression')

  @globalScope = @scope = new @GlobalScope()
  @stack = []

  {@literalExpression} = @LiteralExpression
  {@literalValue} = @LiteralValue

  @pushScope = (scope) ->
    @stack.push(@scope)
    @scope = scope

  @popScope = ->
    @scope = @stack.pop()
}

global = statements { @globalScope.toMGLGlobalScope() }

identifier = a:[a-z]b:[a-z0-9-]* { a + b.join("") }

whitespace =  (("\n" / "\r" / "\t" / " ")* / !.) { null }
statementSeperator = ("\n" / "\r" / ";" / !.) whitespace { null }
argumentSeperator = ((("\t" / " ")* "," ("\t" / " ")*) / ("\t" / " ")+) { null }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                  Scopes                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

scope =
  layerScope /
  classScope /
  sourceScope /
  ruleMacroDefinitionScope

layerScope =
  ("#" name:identifier { @pushScope(@scope.addLayerScope(name)) }) scopeBody

classScope =
  ("." name:identifier { @pushScope(@scope.addClassScope(name)) }) scopeBody

sourceScope =
  ("&" name:identifier { @pushScope(@scope.addSourceScope(name)) }) scopeBody

ruleMacroDefinitionScope =
  (name:identifier args:ruleMacroDefinitionScopeArguments whitespace "=" whitespace { @pushScope(@scope.addRuleMacro(name, args)) }) scopeBody

ruleMacroDefinitionScopeArguments =
  "(" head:ruleMacroDefinitionScopeArgument tail:(argumentSeperator ruleMacroDefinitionScopeArgument)* ")" { [head].concat(tail.map (e) -> e[1] ) } /
  "" { return [] }

ruleMacroDefinitionScopeArgument =
  name:identifier whitespace "=" whitespace expression:valueExpression { name: name, expression:expression } /
  name:identifier { name: name }

scopeBody =
  (whitespace "{" body:statements "}" { @popScope() })

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Statements                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

statements = whitespace (statement (statementSeperator statement)* statementSeperator? whitespace)?

statement =
  sourceRule /
  filterRule /
  valueMacroDefinition /
  rule /
  metaRule /
  scope

sourceRule =
  "$source:" whitespace "&" source:identifier { @scope.setSource(source) }

filterRule =
 "$filter:" whitespace expression:filterExpression { @scope.setFilter(expression) }

metaRule =
  "$" name:identifier ":" whitespace expressions:valueExpressions { @scope.addMetaRule(name, expressions) }

rule =
  name:identifier ":" whitespace expressions:valueExpressions { @scope.addRule(name, expressions) }

valueMacroDefinition =
  name:identifier args:valueMacroDefinitionArguments whitespace "=" whitespace expressions:valueExpressions { @scope.addValueMacro(name, args, expressions) }

valueMacroDefinitionArguments =
  "(" head:valueMacroDefinitionArgument tail:(argumentSeperator valueMacroDefinitionArgument)* ")" { [head].concat(@_.pluck(tail, 1) ) } /
  "" { return [] }

valueMacroDefinitionArgument =
  name:identifier whitespace "=" whitespace expression:valueExpression { name: name, expression: expression } /
  name:identifier { name: name }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                 Expression                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////
//           Filter Expression             //
/////////////////////////////////////////////

filterExpression =
  notOperatorFilterExpression /
  booleanLogicFilterExpression /
  leafFilterExpression

booleanLogicFilterExpression =
  whitespace left:leafFilterExpression whitespace operator:("||" / "&&") whitespace right:filterExpression { new @BooleanLogicExpression(operator, [left, right]) }

notOperatorFilterExpression =
  "!" whitespace expression:filterExpression { new @NotOperatorExpression(expression) }

// Leaf Filter Expressions

leafFilterExpression =
  groupFilterExpression /
  setOperatorFilterExpression /
  comparisonOperatorFilterExpression /
  typeCheckOperatorFilterExpression

groupFilterExpression =
  whitespace "(" expression:filterExpression ")" { expression }

typeCheckOperatorFilterExpression =
  whitespace "is" whitespace type:valueExpression { new @TypeCheckOperatorExpression(type) } /

comparisonOperatorFilterExpression =
  whitespace left:valueExpression whitespace operator:("==" / ">=" / "<=" / "<" / ">" / "!=") whitespace right:valueExpression { new @ComparisonOperatorExpression(left, operator, right) }

setOperatorFilterExpression =
  whitespace left:valueExpression whitespace operator:("in" / "!in") whitespace right:valueExpression { new @SetOperatorExpression(left, operator, right) }

/////////////////////////////////////////////
//           Value Expression              //
/////////////////////////////////////////////

valueExpressions =
  head:valueExpression tail:(argumentSeperator valueExpression)* { [head].concat(tail.map (e) -> e[1]) }

valueExpression =
  literalValueExpression /
  valueMacroReferenceValueExpression /
  stringExpression

valueMacroReferenceValueExpression =
  name:identifier expressions:valueMacroReferenceValueExpressionArguments { new @ValueMacroReferenceExpression(name, expressions) }

valueMacroReferenceValueExpressionArguments =
  "(" head:valueMacroReferenceValueExpressionArgument tail:(argumentSeperator valueMacroReferenceValueExpressionArgument)* ")" { [head].concat(@_.pluck(tail, 1) ) } /
  "" { [] }

valueMacroReferenceValueExpressionArgument =
  name:(identifier / integer) whitespace ":" whitespace expression:valueExpression { name: name, expression: expression } /
  expression:valueExpression { { expression: expression } }

stringExpression =
  "\"" body:[^\"]* "\"" { new @StringExpression(body.join("")) }

literalValueExpression =
  value:value { @literalExpression value }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                                  Value                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

value =
  booleanValue /
  numberValue /
  attributeReferenceValue /
  colorValue /
  arrayValue

arrayValue =
  "[" expressions:valueExpressions "]" { return new @ArrayValue(expressions) }

booleanValue =
  "true" { @literalValue true } /
  "false" { @literalValue false }

numberValue =
  before:integer? "." after:([0-9]+) { @literalValue (before + parseFloat("." + after.join(""))) } /
  number:integer { @literalValue number }

integer =
  head:[1-9] tail:[0-9]* { parseInt(head + tail.join("")) } /
  "0" { 0 }

attributeReferenceValue =
  "@" name:identifier { new @AttributeReferenceValue(name) }

colorValue =
  "#" color:[0-9a-f]+ { @ColorValue.hex(color.join("")) }

