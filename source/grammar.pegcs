{
  require 'sugar'

  @ScreeSS = require '../source/screess'

  @globalScope = @scope = new @ScreeSS.GlobalScope()
  @stack = []

  @literal = (value) => new @ScreeSS.LiteralExpression(value)

  @pushScope = (scope) ->
    @stack.push(@scope)
    @scope = scope
  @popScope = ->
    @scope = @stack.pop()
}

global = statements { @globalScope.evaluate() }

identifier = a:[a-z]b:[a-z0-9-]* { a + b.join("") }

w =  (("\n" / "\r" / "\t" / " ")* / !.) { null }
s = ("\n" / "\r" / ";" / !.) w { null }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             Statements                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

statements = w (statement w)*

statement =
  valueMacroDefinition /
  rule /
  layerScope /
  classScope /
  ruleMacroDefinition

layerScope = ("#" name:identifier { @pushScope(@scope.addLayerScope(name)) }) scope
classScope = ("." name:identifier { @pushScope(@scope.addClassScope(name)) }) scope
scope = (w "{" w body:statements w "}" w { @popScope() })

rule =
  name:identifier w ":" w expressions:expressions s { @scope.addRule(name, expressions) }

valueMacroDefinition =
  name:identifier args:valueMacroDefinitionArguments w "=" w body:expression s
  { @scope.addValueMacro(name, args, body) }

valueMacroDefinitionArguments =
  "(" head:identifier tail:(w identifier)* ")" { [head].concat(tail.map (e) -> e[1] ) } /
  "" { return [] }

ruleMacroDefinition =
  (name:identifier args:ruleMacroDefinitionArguments { @pushScope(@scope.addRuleMacro(name, args)) }) scope

ruleMacroDefinitionArguments =
  "(" head:identifier tail:(w identifier)* ")" { [head].concat(tail.map (e) -> e[1] ) } /
  "" { return [] }

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             Expressions                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

expressions = head:expression tail:(" "+ expression)* { [head].concat(tail.map (e) -> e[1]) }

expression = number / boolean / valueMacroReference

boolean = "true" { @literal true } / "false" { @literal false }

number =
  before:integer? "." after:([0-9]+) { @literal before + parseFloat("." + after.join("")) } /
  integer

integer =
  head:[1-9] tail:[0-9]* { @literal parseInt(head + tail.join("")) } /
  "0" { 0 }

valueMacroReference = name:identifier args:valueMacroReferenceArguments { new @ScreeSS.ValueMacroReferenceExpression(name, args) }

valueMacroReferenceArguments =
  "(" head:expression tail:(w expression)* ")" { [head].concat(tail.map (e) -> e[3] ) } /
  "" { [] }
