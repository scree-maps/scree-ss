// Generated by CoffeeScript 1.8.0
(function() {
  var Scope, Value, assert, _;

  Value = require("../values/value");

  assert = require("assert");

  _ = require("../utilities");

  module.exports = Scope = (function() {
    function Scope(parent) {
      this.parent = parent;
      assert(!this.parent || _.is(this.parent, Scope));
      this.rules = {};
      this.valueMacros = [];
      this.ruleMacros = [];
    }

    Scope.prototype.getGlobalScope = function() {
      return this.parent.getGlobalScope();
    };

    Scope.prototype.addRule = function(name, expressions) {
      if (this.rules[name]) {
        throw new Error("Duplicate entries for rule '" + name + "'");
      }
      return this.rules[name] = expressions;
    };

    Scope.prototype.addValueMacro = function(name, args, body) {
      var ValueMacro, macro;
      ValueMacro = require("../macros/ValueMacro");
      if (_.isArray(body)) {
        macro = ValueMacro.createFromExpressions(name, args, this, body);
      } else if (_.isFunction) {
        macro = ValueMacro.createFromFunction(name, args, this, body);
      }
      return this.valueMacros.unshift(macro);
    };

    Scope.prototype.addRuleMacro = function(name, args, body) {
      var RuleMacro, macro;
      RuleMacro = require("../macros/RuleMacro");
      macro = new RuleMacro(this, name, args, body);
      this.ruleMacros.unshift(macro);
      return macro.scope;
    };

    Scope.prototype.getSourceScope = function(name) {
      var _ref;
      return this.sourceScopes[name] || ((_ref = this.parent) != null ? _ref.getSourceScope(name) : void 0);
    };

    Scope.prototype.getValueMacro = function(name, argValues, options) {
      var macro, _i, _len, _ref, _ref1;
      _ref = this.valueMacros;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        macro = _ref[_i];
        if (macro.matches(name, argValues) && !_.contains(options.valueMacroStack, macro)) {
          return macro;
        }
      }
      return (_ref1 = this.parent) != null ? _ref1.getValueMacro(name, argValues, options) : void 0;
    };

    Scope.prototype.getRuleMacro = function(name, argValues, options) {
      var macro, _i, _len, _ref, _ref1;
      _ref = this.ruleMacros;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        macro = _ref[_i];
        if (macro.matches(name, argValues) && !_.contains(options.ruleMacroStack, macro)) {
          return macro;
        }
      }
      return (_ref1 = this.parent) != null ? _ref1.getRuleMacro(name, argValues, options) : void 0;
    };

    Scope.prototype.toMGLRules = function(options, rules) {
      var expressions, name, output, ruleMacro, values;
      output = {};
      for (name in rules) {
        expressions = rules[name];
        options.rule = name;
        values = _.flatten(_.map(expressions, (function(_this) {
          return function(expression) {
            return expression.toValues(_this, options);
          };
        })(this)));
        if ((ruleMacro = this.getRuleMacro(name, values, options))) {
          options.ruleMacroStack.push(ruleMacro);
          _.extend(output, ruleMacro.toMGLScope(values, options));
          options.ruleMacroStack.pop();
        } else {
          if (values.length !== 1) {
            throw new Error("Cannot apply " + values.length + " args to primitive rule '" + name + "'");
          }
          output[name] = values[0].toMGLValue(options);
        }
        options.rule = null;
      }
      return output;
    };

    return Scope;

  })();

}).call(this);
